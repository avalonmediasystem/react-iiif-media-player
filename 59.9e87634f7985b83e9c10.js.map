{"version":3,"sources":["webpack:///./node_modules/iiif-explorer/dist/esm-es5/helpers-b7c9db54.js","webpack:///./node_modules/iiif-explorer/dist/esm-es5/input-shims-c96fb210.js"],"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","raf","h","__zone_symbol__requestAnimationFrame","requestAnimationFrame","setTimeout","hasShadowDom","el","shadowRoot","attachShadow","findItemLabel","componentEl","itemEl","closest","querySelector","renderHiddenInput","always","container","name","value","disabled","input","ownerDocument","createElement","type","classList","add","appendChild","clamp","min","n","max","Math","assert","actual","reason","message","console","error","Error","now","ev","timeStamp","Date","pointerCoord","changedTouches","touch","x","clientX","y","clientY","undefined","pageX","pageY","isEndSide","side","isRTL","document","dir","debounceEvent","event","wait","original","_original","emit","debounce","bind","func","timer","args","_i","clearTimeout","apply","cloneMap","WeakMap","relocateInput","inputEl","shouldRelocate","inputRelativeY","has","addClone","removeClone","isFocused","getRootNode","activeElement","parentEl","parentNode","clonedEl","cloneNode","tabIndex","set","tx","style","pointerEvents","transform","clone","get","delete","remove","SKIP_SELECTOR","calcScrollData","inputRect","contentRect","keyboardHeight","platformHeight","inputTop","top","inputBottom","bottom","visibleAreaTop","safeAreaTop","distanceToBottom","distanceToTop","desiredScrollAmount","round","scrollAmount","duration","abs","scrollDuration","scrollPadding","inputSafeY","jsSetFocus","contentEl","scrollData","getBoundingClientRect","defaultView","innerHeight","getScrollData","focus","scrollByPoint","then","hasPointerMoved","threshold","startCoord","endCoord","deltaX","deltaY","setScrollPadding","tagName","parentElement","setProperty","startInputShims","config","doc","getNumber","scrollAssist","getBoolean","hideCaret","inputBlurring","inputs","from","querySelectorAll","hideCaretMap","scrollAssistMap","registerInput","scrollEl","rmFn","scrollHideCaret","shouldHideCaret","onBlur","showCaret","addEventListener","removeEventListener","enableHideCaretOnScroll","coord","touchStart","touchEnd","preventDefault","stopPropagation","enableScrollAssist","focused","didScroll","onScroll","onFocusin","onTouchend","active","matches","tapped","target","blur","enableInputBlurring","onFocusout","enableScrollPadding","inputs_1","detail","fn","unregisterInput"],"mappings":"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","file":"59.9e87634f7985b83e9c10.js","sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n/**\r\n * Patched version of requestAnimationFrame that avoids ngzone\r\n * Use only when you know ngzone should not run\r\n */\r\nvar raf = function (h) {\r\n    if (typeof __zone_symbol__requestAnimationFrame === 'function') {\r\n        return __zone_symbol__requestAnimationFrame(h);\r\n    }\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        return requestAnimationFrame(h);\r\n    }\r\n    return setTimeout(h);\r\n};\r\nvar hasShadowDom = function (el) {\r\n    return !!el.shadowRoot && !!el.attachShadow;\r\n};\r\nvar findItemLabel = function (componentEl) {\r\n    var itemEl = componentEl.closest('ion-item');\r\n    if (itemEl) {\r\n        return itemEl.querySelector('ion-label');\r\n    }\r\n    return null;\r\n};\r\nvar renderHiddenInput = function (always, container, name, value, disabled) {\r\n    if (always || hasShadowDom(container)) {\r\n        var input = container.querySelector('input.aux-input');\r\n        if (!input) {\r\n            input = container.ownerDocument.createElement('input');\r\n            input.type = 'hidden';\r\n            input.classList.add('aux-input');\r\n            container.appendChild(input);\r\n        }\r\n        input.disabled = disabled;\r\n        input.name = name;\r\n        input.value = value || '';\r\n    }\r\n};\r\nvar clamp = function (min, n, max) {\r\n    return Math.max(min, Math.min(n, max));\r\n};\r\nvar assert = function (actual, reason) {\r\n    if (!actual) {\r\n        var message = 'ASSERT: ' + reason;\r\n        console.error(message);\r\n        debugger; // tslint:disable-line\r\n        throw new Error(message);\r\n    }\r\n};\r\nvar now = function (ev) {\r\n    return ev.timeStamp || Date.now();\r\n};\r\nvar pointerCoord = function (ev) {\r\n    // get X coordinates for either a mouse click\r\n    // or a touch depending on the given event\r\n    if (ev) {\r\n        var changedTouches = ev.changedTouches;\r\n        if (changedTouches && changedTouches.length > 0) {\r\n            var touch = changedTouches[0];\r\n            return { x: touch.clientX, y: touch.clientY };\r\n        }\r\n        if (ev.pageX !== undefined) {\r\n            return { x: ev.pageX, y: ev.pageY };\r\n        }\r\n    }\r\n    return { x: 0, y: 0 };\r\n};\r\n/**\r\n * @hidden\r\n * Given a side, return if it should be on the end\r\n * based on the value of dir\r\n * @param side the side\r\n * @param isRTL whether the application dir is rtl\r\n */\r\nvar isEndSide = function (side) {\r\n    var isRTL = document.dir === 'rtl';\r\n    switch (side) {\r\n        case 'start': return isRTL;\r\n        case 'end': return !isRTL;\r\n        default:\r\n            throw new Error(\"\\\"\" + side + \"\\\" is not a valid value for [side]. Use \\\"start\\\" or \\\"end\\\" instead.\");\r\n    }\r\n};\r\nvar debounceEvent = function (event, wait) {\r\n    var original = event._original || event;\r\n    return {\r\n        _original: event,\r\n        emit: debounce(original.emit.bind(original), wait)\r\n    };\r\n};\r\nvar debounce = function (func, wait) {\r\n    if (wait === void 0) { wait = 0; }\r\n    var timer;\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        clearTimeout(timer);\r\n        timer = setTimeout.apply(void 0, __spreadArrays([func, wait], args));\r\n    };\r\n};\r\nexport { renderHiddenInput as a, assert as b, clamp as c, debounceEvent as d, debounce as e, findItemLabel as f, hasShadowDom as h, isEndSide as i, now as n, pointerCoord as p, raf as r };\r\n","import { p as pointerCoord } from './helpers-b7c9db54.js';\r\nvar cloneMap = new WeakMap();\r\nvar relocateInput = function (componentEl, inputEl, shouldRelocate, inputRelativeY) {\r\n    if (inputRelativeY === void 0) { inputRelativeY = 0; }\r\n    if (cloneMap.has(componentEl) === shouldRelocate) {\r\n        return;\r\n    }\r\n    if (shouldRelocate) {\r\n        addClone(componentEl, inputEl, inputRelativeY);\r\n    }\r\n    else {\r\n        removeClone(componentEl, inputEl);\r\n    }\r\n};\r\nvar isFocused = function (input) {\r\n    return input === input.getRootNode().activeElement;\r\n};\r\nvar addClone = function (componentEl, inputEl, inputRelativeY) {\r\n    // this allows for the actual input to receive the focus from\r\n    // the user's touch event, but before it receives focus, it\r\n    // moves the actual input to a location that will not screw\r\n    // up the app's layout, and does not allow the native browser\r\n    // to attempt to scroll the input into place (messing up headers/footers)\r\n    // the cloned input fills the area of where native input should be\r\n    // while the native input fakes out the browser by relocating itself\r\n    // before it receives the actual focus event\r\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\r\n    var parentEl = inputEl.parentNode;\r\n    // DOM WRITES\r\n    var clonedEl = inputEl.cloneNode(false);\r\n    clonedEl.classList.add('cloned-input');\r\n    clonedEl.tabIndex = -1;\r\n    parentEl.appendChild(clonedEl);\r\n    cloneMap.set(componentEl, clonedEl);\r\n    var doc = componentEl.ownerDocument;\r\n    var tx = doc.dir === 'rtl' ? 9999 : -9999;\r\n    componentEl.style.pointerEvents = 'none';\r\n    inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\r\n};\r\nvar removeClone = function (componentEl, inputEl) {\r\n    var clone = cloneMap.get(componentEl);\r\n    if (clone) {\r\n        cloneMap.delete(componentEl);\r\n        clone.remove();\r\n    }\r\n    componentEl.style.pointerEvents = '';\r\n    inputEl.style.transform = '';\r\n};\r\nvar enableHideCaretOnScroll = function (componentEl, inputEl, scrollEl) {\r\n    if (!scrollEl || !inputEl) {\r\n        return function () { return; };\r\n    }\r\n    var scrollHideCaret = function (shouldHideCaret) {\r\n        if (isFocused(inputEl)) {\r\n            relocateInput(componentEl, inputEl, shouldHideCaret);\r\n        }\r\n    };\r\n    var onBlur = function () { return relocateInput(componentEl, inputEl, false); };\r\n    var hideCaret = function () { return scrollHideCaret(true); };\r\n    var showCaret = function () { return scrollHideCaret(false); };\r\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\r\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\r\n    inputEl.addEventListener('blur', onBlur);\r\n    return function () {\r\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\r\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\r\n        inputEl.addEventListener('ionBlur', onBlur);\r\n    };\r\n};\r\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\r\nvar enableInputBlurring = function () {\r\n    var focused = true;\r\n    var didScroll = false;\r\n    var doc = document;\r\n    var onScroll = function () {\r\n        didScroll = true;\r\n    };\r\n    var onFocusin = function () {\r\n        focused = true;\r\n    };\r\n    var onTouchend = function (ev) {\r\n        // if app did scroll return early\r\n        if (didScroll) {\r\n            didScroll = false;\r\n            return;\r\n        }\r\n        var active = doc.activeElement;\r\n        if (!active) {\r\n            return;\r\n        }\r\n        // only blur if the active element is a text-input or a textarea\r\n        if (active.matches(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        // if the selected target is the active element, do not blur\r\n        var tapped = ev.target;\r\n        if (tapped === active) {\r\n            return;\r\n        }\r\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\r\n            return;\r\n        }\r\n        focused = false;\r\n        // TODO: find a better way, why 50ms?\r\n        setTimeout(function () {\r\n            if (!focused) {\r\n                active.blur();\r\n            }\r\n        }, 50);\r\n    };\r\n    doc.addEventListener('ionScrollStart', onScroll);\r\n    doc.addEventListener('focusin', onFocusin, true);\r\n    doc.addEventListener('touchend', onTouchend, false);\r\n    return function () {\r\n        doc.removeEventListener('ionScrollStart', onScroll, true);\r\n        doc.removeEventListener('focusin', onFocusin, true);\r\n        doc.removeEventListener('touchend', onTouchend, false);\r\n    };\r\n};\r\nvar SCROLL_ASSIST_SPEED = 0.3;\r\nvar getScrollData = function (componentEl, contentEl, keyboardHeight) {\r\n    var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\r\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\r\n};\r\nvar calcScrollData = function (inputRect, contentRect, keyboardHeight, platformHeight) {\r\n    // compute input's Y values relative to the body\r\n    var inputTop = inputRect.top;\r\n    var inputBottom = inputRect.bottom;\r\n    // compute visible area\r\n    var visibleAreaTop = contentRect.top;\r\n    var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\r\n    // compute safe area\r\n    var safeAreaTop = visibleAreaTop + 15;\r\n    var safeAreaBottom = visibleAreaBottom * 0.5;\r\n    // figure out if each edge of the input is within the safe area\r\n    var distanceToBottom = safeAreaBottom - inputBottom;\r\n    var distanceToTop = safeAreaTop - inputTop;\r\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\r\n    var desiredScrollAmount = Math.round((distanceToBottom < 0)\r\n        ? -distanceToBottom\r\n        : (distanceToTop > 0)\r\n            ? -distanceToTop\r\n            : 0);\r\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\r\n    // gets focus, so make sure we don't scroll the input above the visible area\r\n    var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\r\n    var distance = Math.abs(scrollAmount);\r\n    var duration = distance / SCROLL_ASSIST_SPEED;\r\n    var scrollDuration = Math.min(400, Math.max(150, duration));\r\n    return {\r\n        scrollAmount: scrollAmount,\r\n        scrollDuration: scrollDuration,\r\n        scrollPadding: keyboardHeight,\r\n        inputSafeY: -(inputTop - safeAreaTop) + 4\r\n    };\r\n};\r\nvar enableScrollAssist = function (componentEl, inputEl, contentEl, keyboardHeight) {\r\n    var coord;\r\n    var touchStart = function (ev) {\r\n        coord = pointerCoord(ev);\r\n    };\r\n    var touchEnd = function (ev) {\r\n        // input cover touchend/mouseup\r\n        if (!coord) {\r\n            return;\r\n        }\r\n        // get where the touchend/mouseup ended\r\n        var endCoord = pointerCoord(ev);\r\n        // focus this input if the pointer hasn't moved XX pixels\r\n        // and the input doesn't already have focus\r\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\r\n            ev.preventDefault();\r\n            ev.stopPropagation();\r\n            // begin the input focus process\r\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\r\n        }\r\n    };\r\n    componentEl.addEventListener('touchstart', touchStart, true);\r\n    componentEl.addEventListener('touchend', touchEnd, true);\r\n    return function () {\r\n        componentEl.removeEventListener('touchstart', touchStart, true);\r\n        componentEl.removeEventListener('touchend', touchEnd, true);\r\n    };\r\n};\r\nvar jsSetFocus = function (componentEl, inputEl, contentEl, keyboardHeight) {\r\n    var scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\r\n    if (Math.abs(scrollData.scrollAmount) < 4) {\r\n        // the text input is in a safe position that doesn't\r\n        // require it to be scrolled into view, just set focus now\r\n        inputEl.focus();\r\n        return;\r\n    }\r\n    // temporarily move the focus to the focus holder so the browser\r\n    // doesn't freak out while it's trying to get the input in place\r\n    // at this point the native text input still does not have focus\r\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\r\n    inputEl.focus();\r\n    // scroll the input into place\r\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(function () {\r\n        // the scroll view is in the correct position now\r\n        // give the native text input focus\r\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\r\n        // ensure this is the focused input\r\n        inputEl.focus();\r\n    });\r\n};\r\nvar hasPointerMoved = function (threshold, startCoord, endCoord) {\r\n    if (startCoord && endCoord) {\r\n        var deltaX = (startCoord.x - endCoord.x);\r\n        var deltaY = (startCoord.y - endCoord.y);\r\n        var distance = deltaX * deltaX + deltaY * deltaY;\r\n        return distance > (threshold * threshold);\r\n    }\r\n    return false;\r\n};\r\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\r\nvar enableScrollPadding = function (keyboardHeight) {\r\n    var doc = document;\r\n    var onFocusin = function (ev) {\r\n        setScrollPadding(ev.target, keyboardHeight);\r\n    };\r\n    var onFocusout = function (ev) {\r\n        setScrollPadding(ev.target, 0);\r\n    };\r\n    doc.addEventListener('focusin', onFocusin);\r\n    doc.addEventListener('focusout', onFocusout);\r\n    return function () {\r\n        doc.removeEventListener('focusin', onFocusin);\r\n        doc.removeEventListener('focusout', onFocusout);\r\n    };\r\n};\r\nvar setScrollPadding = function (input, keyboardHeight) {\r\n    if (input.tagName !== 'INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\r\n        return;\r\n    }\r\n    if (input.parentElement &&\r\n        input.parentElement.parentElement &&\r\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\r\n        return;\r\n    }\r\n    var el = input.closest('ion-content');\r\n    if (el === null) {\r\n        return;\r\n    }\r\n    var timer = el[PADDING_TIMER_KEY];\r\n    if (timer) {\r\n        clearTimeout(timer);\r\n    }\r\n    if (keyboardHeight > 0) {\r\n        el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\r\n    }\r\n    else {\r\n        el[PADDING_TIMER_KEY] = setTimeout(function () {\r\n            el.style.setProperty('--keyboard-offset', '0px');\r\n        }, 120);\r\n    }\r\n};\r\nvar INPUT_BLURRING = true;\r\nvar SCROLL_PADDING = true;\r\nvar startInputShims = function (config) {\r\n    var doc = document;\r\n    var keyboardHeight = config.getNumber('keyboardHeight', 290);\r\n    var scrollAssist = config.getBoolean('scrollAssist', true);\r\n    var hideCaret = config.getBoolean('hideCaretOnScroll', true);\r\n    var inputBlurring = config.getBoolean('inputBlurring', true);\r\n    var scrollPadding = config.getBoolean('scrollPadding', true);\r\n    var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\r\n    var hideCaretMap = new WeakMap();\r\n    var scrollAssistMap = new WeakMap();\r\n    var registerInput = function (componentEl) {\r\n        var inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\r\n        var scrollEl = componentEl.closest('ion-content');\r\n        if (!inputEl) {\r\n            return;\r\n        }\r\n        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\r\n            var rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\r\n            hideCaretMap.set(componentEl, rmFn);\r\n        }\r\n        if (!!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\r\n            var rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\r\n            scrollAssistMap.set(componentEl, rmFn);\r\n        }\r\n    };\r\n    var unregisterInput = function (componentEl) {\r\n        if (hideCaret) {\r\n            var fn = hideCaretMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            hideCaretMap.delete(componentEl);\r\n        }\r\n        if (scrollAssist) {\r\n            var fn = scrollAssistMap.get(componentEl);\r\n            if (fn) {\r\n                fn();\r\n            }\r\n            scrollAssistMap.delete(componentEl);\r\n        }\r\n    };\r\n    if (inputBlurring && INPUT_BLURRING) {\r\n        enableInputBlurring();\r\n    }\r\n    if (scrollPadding && SCROLL_PADDING) {\r\n        enableScrollPadding(keyboardHeight);\r\n    }\r\n    // Input might be already loaded in the DOM before ion-device-hacks did.\r\n    // At this point we need to look for all of the inputs not registered yet\r\n    // and register them.\r\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\r\n        var input = inputs_1[_i];\r\n        registerInput(input);\r\n    }\r\n    doc.addEventListener('ionInputDidLoad', (function (ev) {\r\n        registerInput(ev.detail);\r\n    }));\r\n    doc.addEventListener('ionInputDidUnload', (function (ev) {\r\n        unregisterInput(ev.detail);\r\n    }));\r\n};\r\nexport { startInputShims };\r\n"],"sourceRoot":""}